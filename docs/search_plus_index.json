{"./":{"url":"./","title":"Introduction","keywords":"","body":"本书拟作为外脑，主要内容包括： 写代码的 Python类库方法 Pandas Numpy Matpltlib Os IDE Pycharm DataSpell MatLab Jupyter Vscode Visual Studio 爬虫相关 控制键鼠 Html元素提取 selenium自动化 cookie和header get请求 post请求 js解密 正则表达式 提取字符串 匹配字符串 远程 SSH 远程开发 个人服务器 租用 配置 Linux系统 研究生阶段 专业课程 其他兴趣（暂未成型） C++学习 嵌入式开发 Jsp开发 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:13 "},"暑期实习投递.html":{"url":"暑期实习投递.html","title":"没办法，得投暑期实习","keywords":"","body":"话术 应用统计（数据科学方向）研一在读，有扎实的数理统计基础，擅长数据建模与分析。热衷计算机和数据分析，有3年的程序编写经验，熟练掌握Python, MatLab和R语言编程。积极实践自由开源精神，在GitHub上分享多个项目，并为开源项目做出贡献。并在Bilibili平台发布爬虫等程序教程 四川省金融科技学会 指数框架优化：分别从行业基础环境、科学技术资源和金融科技市场三个方面构建框架 数据获取：编写代码，实现爬取知网、企查查、天眼查等平台数据 指数计算：数据预处理，并根据模型计算得到各省的2021年天府金融科技指数 旷惟私募基金管理有限公司 数据维护：底层数据维护，框架计算优化，自有平台维护，数据供应商对接等 代码需求实现：构建单因子回测框架，爬取部分平台数据、L2 订单簿数据分析等 投研框架实现：流通股东框架开发，分析师预期框架开发、社交媒体情感框架等 基于贝叶斯算法的参数反演，研究课题-中广核 使用 MCMC 和贝叶斯算法，求解核反应堆腐蚀模型微分方程的最优参数，并撰写相关工作报告 编写代MATLAB代码，并撰写项目报告 微博数据采集 采集微博用户的微博数据，包括用户信息，微博评论，点赞等 易于使用：已发布至Pypi,可通过pip安装 速度较快：采用多线程，实现高速爬取 便于扩展：通过继承方式，实现对爬取内容的扩展 20230420 东方证券量化 东方证券- 校园招聘 (mokahr.com) 国海证券量化投资助理 广大证券金融科技上海 我的申请 (zhiye.com) 瑞银金融科技 卡方科技量化 20230418 宽德大数据开发 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"资源网站.html":{"url":"资源网站.html","title":"资源网站","keywords":"","body":"软件应用下载官网/镜像 calibre 中国区下载地址：calibre - 下载 Windows (calibre-ebook.com) 【推荐】镜像网站：calibre下载 OpenCV-Python 【推荐】清华镜像：Links for opencv-python (tsinghua.edu.cn) Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"软件推荐.html":{"url":"软件推荐.html","title":"亲测好用的软件","keywords":"","body":"IDE 本人目前只会Python, Pycharm 个人项目的主要开发平台 推荐理由 集成化程度高, 开箱即用, 很多功能都内置, 包括git 的 gui, 数据库连接, 服务器部署等 便捷的虚拟环境创建与切换 新版的UI还是很好看的 JetBrains家的DataSpell用来专门写notebook, 以及DataGrip用来管理数据库 Tips 学生邮箱可以申请专业版, 并无限延期(前提是校园邮箱可以使用) 额外注意 占用内存大, 亲测32G内存都不一定扛得动住, 当然可以限制内存使用 远程连接不如vscode好用, 得额外安装软件 Visual Studio Code 工作使用, 丰富的插件生态 推荐理由 免费 无缝连接远程服务器, 开发非常流程 不占内存, 响应快 丰富的插件, 按需安装 设置同步功能, 让你多种工作场景无缝衔接 额外注意 刚入门可能需要配置一些东西, 需要耐心 Git工具 Fork 独立的Git管理工具，提供可视化的操作界面，并可以自定义打开软件，下载链接 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-11-19 19:43:39 "},"奇怪的技巧.html":{"url":"奇怪的技巧.html","title":"旁门左道","keywords":"","body":"记录一些杂七杂八但是经常用到的技巧 python代码块 GUI读取文件路径 import tkinter as tk from tkinter import filedialog def getLocalFile(): root = tk.Tk() root.withdraw() filePath = filedialog.askopenfilename() print('文件路径：', filePath) return filePath Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"编码格式.html":{"url":"编码格式.html","title":"既爱又恨的编码格式","keywords":"","body":"期待经过一段时间的积累，能够避免很多编码格式遇到的问题 Python相关 很多时候，都是utf-8和gbk两种编码格式的冲突，很多时候用记事本打开，然后指定为gbk格式另存，能够解决大部分问题，但是有时候也有些字符无法转换。所以最好是在写代码时规避这些内容！ Encode和Decode unicode 是一种无编码格式的状态，不同的应用会自动尝试用一些自以为正确的编码格式（如utf-8、gbk)等格式解码 encode encode（）方法就是将unicode编码方式转化为对应的实现方式 str.decode(encoding=“utf-8”, errors='strict') # 严格 decode decode（）方法就是实现方式变回Unicode str.encode(encoding=“utf-8”, errors='ignore') #忽略错误 写入正常，结果打开乱码 写入csv，结果打开乱码 奇技淫巧，指定编码格式为utf-8-sig，似乎这种编码格式是utf-8和gbk格式的交际，具体忘记了；按道理来说应该先试一试gbk格式 data_df.to_csv(filename.csv, index=False, encoding='utf-8-sig') 写入报错，有些字符不能转换 读取json文件，写入csv报错 原因应该是有些字符串可以使用utf-8解码显示，但是无法重新编码为gbk，就比如一些/u200，真是让人头大，奇技淫巧之忽略，先解码为gbk再编码 answer_Full = answer_Full.encode('gbk','ignore').decode('gbk') # 设置忽略错误 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"datetime&to_datetime.html":{"url":"datetime&to_datetime.html","title":"datetime与pd.to_datetime对比","keywords":"","body":"datetime import datetime # 导入库 datetime.datetime.today() 获取当前时间 datetime.datetime.today() # Out[19]: datetime.datetime(2023, 4, 3, 23, 15, 38, 611194) # type为datetime.datetime 处理为日期数据 datetime.datetime.today().date() # Out[23]: datetime.date(2023, 4, 3) # type为datetime.date str转datetime.datetime day1 = datetime.datetime.today().date() day1.strftime(\"%Y%m%d\") # Out[30]: '20230403' # type为str datetime.datetime转str datetime.datetime.strptime('20200101','%Y%m%d') # Out[34]: datetime.datetime(2020, 1, 1, 0, 0) # type为datetime.datetime pandas.to_datetime str转timestamps.Timestamp pd.to_datetime(\"20200101\") # Out[37]: Timestamp('2020-01-01 00:00:00') # type为pandas._libs.tslibs.timestamps.Timestamp timestamps.Timestamp转str day2 = pd.to_datetime(\"20200101\") day2.strftime('%Y%m%d') # Out[40]: '20200101' # type为str timestamps.Timestamp转datetime.date day2.date() # Out[41]: datetime.date(2020, 1, 1) # type为datetime.date timestamps.Timestamp查看周几 day2.day_name() Out[44]: 'Wednesday' Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"Python.html":{"url":"Python.html","title":"Python","keywords":"","body":"这里将储存使用Python中遇到的问题及解决方案，记录自己的学习过程及经验。 目前已有主题: Python类库安装 Pd.DataFrame数据处理相关 时间格式数据处理 Numpy相关 Python的IDE配置 正则表达式 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:13 "},"虚拟环境.html":{"url":"虚拟环境.html","title":"Python虚拟环境","keywords":"","body":"拥有多个python解释器是很正常的事情，我们需要厘清其中的关系，不要觉得多就是乱。 Conda:一个成熟的Python环境管理工具 通常意义上Anaconda作为Python的一个发行版本，我们将其当做一个，附赠jupyter、spyder等IDE、下载即安装pandas、numpy等数据科学类库的Python是没有任何问题的。 实际上Anaconda最强大的工具就是conda，以往我们可以用pip进行Python类库的管理，现在我们可以用conda替代，甚至Anaconda Navifator提供了图形化的类库管理界面，可以通过点点实现类库的管理。 虚拟环境 我所认为的虚拟环境就是python的分身，我们将安装Anaconda赠送Python作为base(因为在有了虚拟环境后，这个python后往往都接着一个base)。通过创建虚拟环境，这个base通过复制（只保留基础类库），得到了虚拟环境，可以理解为一个全新的Python，在运行Python程序的时候可以指定用哪一个Python。 不同的项目需要的类库支持往往不一样，当base安装的类库居多时，容易发生包之间的版本冲突或不匹配，所以为不同的类型的项目创建一个单独的虚拟环境（python）是非常有必要的。 创建虚拟环境 这样的创建过程有很多种方式可以完成： Clone项目时，Pycharm询问是否为该项目创建一个虚拟环境，如果选择创建，就会在该项目文件下新建一个envs文件夹，用于存放新的python和该项目接下来需要的包。当然你也可以不选择创建，直接使用已有的环境就成（base或者其他的虚拟环境） 使用Anaconda Navifator创建，点点界面实在是很友好，所以很推荐这种方式创建虚拟环境，并且可以在这直接装好包。 当让是可以使用终端创建，详细的就看别人的介绍就成。 使用虚拟环境 在Pychram中可以通过配置项目解释器的方式指定解释器，但是你会发下Pycharm中的终端还是base解释器，在那装包还是装到base上了，这个时候需要在Pycharm设置中将工具>终端>应用程序设置>Shell路径改为C:\\Windows\\system32\\cmd.exe，这样以来终端中就是项目的环境了。 另外就是如果不用Pycharm，需要先激活activate指定环境，然后再运行程序，或者直接cd到envs路径下，再运行程序，也可以达到目的。 一些命令 查看本地所有的虚拟环境 conda info -e 激活指定环境 activate scrapy 关闭已经激活的环境 conda deactivate Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"Python类库.html":{"url":"Python类库.html","title":"Python类库","keywords":"","body":"记录Python包安装的注意事项 安装问题 指定源，处理超时问题 pip install redis -i http://pypi.douban.com/simple --trusted-host pypi.douban.com 注意安装Python的环境，不要装到别的环境中，可修改pycharm中的终端为cmd，可使得每次使用当前环境执行命令 安装whl 直接使用pip安装对应下载的whl文件即可，注意whl文件的路径，或者将whl移入到Anaconda\\Lib\\site-packages下 pip install Path\\pakageName.whl Conda命令 查找可用的安装版本，并在指定版本安装 conda search numpy conda install numpy=1.9.3 查看环境和删除 conda env list conda env remove --name 判断下载win32还是amd64的whl文件 如果返回32bit，则下载win32，一般都是64位，所以下载amd64.whl import platform platform.architecture() 值得记一下的库 tqdm 用于构建循环进度条 from tqdm import tqdm with tqdm(range(begin, end)) as Range: for i in Range: Range.set_postfix({\"_id\": TaxNum}) # 进度条右边显示信息 retry 修饰器，执行函数重试 from retrying import retry @retry(stop_max_attempt_number=10) # 最多尝试10次 def MainGet(myHeaders, begin, end): pass Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:13 "},"DataFrame函数相关.html":{"url":"DataFrame函数相关.html","title":"DataFrame函数","keywords":"","body":"本节会记录部分处理pd.DadaFrame、pd.Series数据时使用到的方法 pd.DadaFrame函数 判断是否为df if isinstance(data, pd.DataFrame): 创建DataFrame Pandas.DataFrame(data,index,columns) 用于构建DataFrame对象 data可以为list，也可以为pd.series。需要注意的是，如果数据是单个数，需要使用中括号括起来，否则会报Index有关错误 data = {\"col1\":[number1],\"col2\":[number2]} index可以为别的df的索引，也可以写一个list作为索引 columns为列表，用于标记列的名称 使用apply进行行或列遍历 Pandas.DataFrame.apply(func,axis) 用于对df进行遍历操作，类似于MATLAB中对列进行操作实际上是对列中的每个元素进行操作 func，我会写成lambda x: f(x)的形式，官方中说，可以调用一个def(x)，或者是直接使用np.sum()之类的 axis=1就是对列中的每一个进行操作，一般就是这样 demo_df['updateTime'] = demo_df['updateTime'].apply(lambda x:x.split(' ')[0]) 使用groupby进行分组操作 【S01E12】pandas之函数应用：map、apply、agg和transform - 知乎 (zhihu.com) Pandas.DataFrame.groupby(by,axis) 用于对df进行先分组、后操作，值得注意的是，类似Matlab中，分组和操作是分开的，groupby之后只是创建了一个group对象，具体的操作还要再写 by可以是个str就是某一列的列名，或者是list，因为可以进行多级别的分组 axis就是行操作还是列操作 其他还有很参数，目前没用到，举个列子吧，说一下分组以后怎么进一步操作 demo_df.groupby(['secID','endDate','publishDate','updateTime','getDate','cat1'])['holdPct'].sum().sort_index() 输出为csv文件 Pandas.DataFrame.to_csv(filename,mode,encoding,header,index) 这个方法是把内存中的df对象保存到本地 filename是保存文件的名称，其实也可以加上路径，就比如'\\导出数据\\cross\\Shcategory.csv'，但必须保证文件夹存在，否则会报错。建议在代码中加入路径不存在则使用os创建的逻辑 mode是写入的类型，和python写入一样的，我不太熟悉，只用到w是创建并写入，a是追加写入 encoding是写入文件的编码格式，如果想要用Excel打开就是gbk，如果用编辑器查看就是utf-8，不过pycharm可以提醒你用gbk重新打开，不过目前来看最万能的格式是utf_8_sig，两边打开都不会乱码 header表示是否写入表头，追加时不要表头，新写时需要写入表头 index表示是否需要写入索引，一般是不需要的，所以index=FALSE就成，仅当index含有除了序号以外的其他信息的时候，才需要写入 使用merge拼接数据 Pandas.DataFrame.merge(right,how,on,axis) 这个方法类似于Excel中的Vlookup了，根据关键词将两个df匹配拼接起来 right表示需要拼接的df，其实写成pd.merge(left_df,right_df)亲测也可以 how表示拼接方法，可选‘left’, ‘right’, ‘outer’, ‘inner’, ‘cross’, 默认 inner，表示仅保留两个df共有的部分，left表示仅保留左边left的部分 on表示关键词列，如果左右名称不一样，可以分别使用left_on，right_on axis一般就是1了 特别的，使用merge按照Index拼接 data_df.merge(REVS5,left_index=True,right_index=True) 使用concat拼接数据 Pandas.DataFrame.concat([df1,df2],axis) 这个方法是把两个df直接拼接到一起，或许多个df也可以，没有匹配的功能，就是简单拼接 axis = {0:’index’,1:’columns’}, default 0，意思就是说，默认为0表示根据Index进行拼接 还有一些参数，排序之类的就不详细写了，注意的是两个df一定要写在中括号里面 使用replace替换数据中的元素 Pandas.Series.replace() 对Series对象中的符合规定的元素进行替换，可以用正则表达式，很不错 SecData_df['vwap'].replace(0, np.nan, inplace=True) 使用GroupBy.rank进行排序 Pandas.DataFrame.groupby().rank() 这个操作是对某列的数据进行聚类然后对其它列的属于同类数据进行数值大小排序 method的意思是遇到相同的数值怎么算排名，如果选‘average’，那么就会取两个rank的平均数，导致的结果就是rank中会出现小数，如果选‘min'那就是都取最小的排名，如果是‘first’那就是将考前的数值设置为更小的排名 ascending标记排序顺序是从大到小还是从小到大，TRUE表示从小到大 na_option表示了对缺失值NaN怎么处理，{‘keep’,‘top’,‘bottom’}，选为top则是移到顶部 df.groupby(['gender'])['age'].rank() 使用roling实现滚动窗口 Pandas.DataFrame.rolling() 计算滚动窗口的均值，EMA的主要实现方式 使用pivot数据重构 Pandas.DataFrame.pivot() 数据重构的主要实现方式，通过指定index，columns，values实现对原始DataFrame的数据重构 使用re对数据中的str数据处理 Pandas.Series.str.** 这一块就是pandas和re的结合了，但每个方法都很简单，就挨个说一下 pandas.Series.str.contains(pat)，包含pat返回TRUE，pat可以写成正则表达式，可以用|拼接多个 pandas.Series.str.endswith(pat)，以pat结尾返回TRUE，pat可以写成正则表达式，但是不能拼接多个 pandas.Series.str.extract(pat)，使用pat拆分，返回多列，然后使用apply提取内容 pandas.Series.str.len()，返回元素长度 查询元素是否在一个list里出现 Pandas.Series.isin(values) 这个方法，总体上还是类似MatLab，就是对一列里面的每一个元素都操作 values为list或者是str 如果元素在values这个list中，或者就等于这个str（不过这个有点鸡肋，干嘛不直接用==)就在对于的地方返回True，整体上来看，也是属于筛选的某些行的操作范畴 使用drop删除指定部分 Pandas.DataFrame.drop() 这个方法就是删除指定的行了，一般第一个参数是以index为基础的索引，实操中我一般会先做一个tag，然后使用tag == TRUE的index，作为drop的index tag_a = self.CAdf['TradTime'].str.contains('14:5[789]:[0-9]{2}.[0-9]{3}|15:00:[0-9]{2}.[0-9]{3}') self.SecDatadf.drop(tag_a.index[tag_a], inplace=True) # 删除提取出的数据 删除特定列 data_df.drop(columns=['aiq_date','closePrice','turnoverVol']) 序列差分 Pandas.DataFrame.diff(axis=1,periods=1) 做差分，第一个会变成NaN 参数axis表示对几列进行差分 参数periods表示差分跨度，默认为1 self.wheredf['diff'] = self.wheredf[['Vgroup']].diff() 使用iterrows生成迭代器 for index, row in data.iterrows(): # 针对每行数据计算变动 row_dict = {} row_dict['index'] = index row_dict['updateTime'] = row['updateTime'] if index > 0: for col in cols: if data.iloc[index - 1][col] == np.NaN or data.iloc[index][col] == np.NaN: row_dict[col + '_rate'] = np.NaN d1 = float(data.iloc[index - 1][col]) d2 = float(data.iloc[index][col]) rate = (d2 - d1) / d1 row_dict[col + '_rate'] = rate rate_df = rate_df.append(row_dict, ignore_index=True) return rate_df 使用GroupBy生产遍历序列 for author_group, group_df in self.mergedata.groupby(['author', 'secCode']): # 按照每年分组查询 for year, year_df in group_df.groupby('foreYear'): year_df = year_df.sort_values(by='writeDate') # 对研报预测时间进行排序 year_df[field + '_forecast_change'] = year_df.groupby('author')[field].apply(lambda x: (x - x.shift(1)) / x.shift(1)) # 根据要求公式得到想预测字段的变动并储存 year_df = year_df[['author', 'secName', 'foreYear', field + '_forecast_change', 'writeDate', 'publishDate']] self.result = pd.concat([self.result, year_df]) DataFrame切片 loc loc对应的是index，loc中可以直接写对Series对象的逻辑判断 subset.loc[subset['upLimitDay'] == 0] iloc iloc与loc的区别是，loc以index为基准，iloc则是忽略index直接以行数取出。 当然，iloc也可以取多行，例如： df2 = self.wheredf.iloc[where:, :] 直接切 使用尾追一个列表，表示取多少到多少位 target_position[0:10] 切出一个元素 想要提取一个元素（数值或str），目前的方法就是先取为list再取其第一个元素 price = list(temp_df[name])[0] 这两种方法也可以 self.SecID = self.SecDatadf['SecurityID'][0] self.wheredf.loc[indexi]['Vgroup'] pandas分箱 主要步骤是设置箱子bins，注意bins的每个相邻元素之间组成的区间为箱子区间，所以bins元素个数要比箱子个数多一个；然后就是使用Pd.cut进行分箱，几个参数labels为各个箱子的标签，retbins：获取边界值列表，include_lowest字面意思，righ：包含右边界与否 bins = [i * self.targenum for i in range(0, self.cellNum + 1)] # 设置箱子 pd.cut(np.cumsum(self.SecDatadf.TradVolume), bins, labels=range(1, self.cellNum + 1),retbins=False,include_lowest=True, right=True) Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:13 "},"时间格式转换.html":{"url":"时间格式转换.html","title":"时间格式数据处理","keywords":"","body":"这个版块很重要，但是每次都记不住，主要从类库分别记录 datetime类库 构造时间数据对象 直接构建 datetime.date(2019,8,26) 获取今天的时间 datetime.date.today() 取指定时间部分 a = datetime.date.today() a.year # 年 a.month # 月 a.day # 日 str格式转换 将str格式转为时间，随即可以进行仅时间格式可进行的操作 str转时间 datetime.strptime(str,'%H:%M:%S.%f') datetime.strptime(str,'%Y-%m-%d') 时间转str datetime.strftime(str,'%H:%M:%S.%f') 时间间隔timedelta 两时间加减 a1 = datetime.date(2019,8,26) a2 = datetime.date(2019,9,26) (a2 - a1).days # .seconds表示将此间隔转为秒为单位 处理间隔 a1 = datetime.date(2019,8,26) delta = datetime.timedelta(days=10) a1 + delta # 生成等间距时间序列 pd.date_range(start=self.beginDate, end=self.endDate, freq='Q').strftime('%Y%m%d').tolist() 显然其中freq参数控制间隔为季度 pandas中的时间处理 to_datetime：str转时间戳 将某列数据，进行格式化，转换为时间格式 pd.to_datetime('20221101',format='%Y%m%d') # pandas.tseries.offsets：跳转 这部分主要是基于时间戳，获取符合条件的时间，举例说明 转至月末 pd.Timestamp('2017-01-01 09:10:11') + pd.tseries.offsets.MonthEnd(1) 前五年的今天 pd.to_datetime('2022-11-1') - pd.DateOffset(years=5) # pandas.Series.dt：批量操作 对pandas.Series中的每一个时间戳对象，进行批量操作，类似于apply AnalystConsData['writeDate_shift1D'].dt.strftime('%Y-%m-%d') # 时间戳批量转回str Datetime format specification Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"Numpy相关.html":{"url":"Numpy相关.html","title":"Numpy函数","keywords":"","body":"Numpy和Pandas同等地位的存在，但是我实际用到的不多 np.cunsum() 累加 self.wheredf['cumsum'] = np.cumsum(self.SecDatadf.TradVolume) np.max(df) 可以直接取得df中的最大值，还挺不错，min也是一样 mymax = np.max(df) Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:13 "},"Python的IDE配置.html":{"url":"Python的IDE配置.html","title":"python的IDE配置","keywords":"","body":"主要介绍几个常用的Python IDE工具 Pycharm 解释器设置 新开一个项目，运行代码时，要设置解释器，就是选一个本地的Python，如果不能自动识别，那可能需要手动添加路径或者是重新安装一个内核了。 不够主流的应该是给每一个项目创建一个虚拟环境，目前我的库都比较单一，所以目前没有虚拟环境的需求，便都使用本地原始编辑器。 插件 Gitee 实现本地与Gitee仓库的连接，因为Github连接不稳定，所以使用Gitee作为临时替代 WakaTime 记录conding时间 .ignore 创建.ignore文件，使得git屏蔽上传一些文件，新增屏蔽的时候只需要在.ignore中写入文件名就成 Vscode 优点： 总体感觉比Vscode要强，具体强在哪也说不太出来，反正对于项目化管理，一项目设置体验Vscode没有 以gbk格式编码的CSV，Pycharm可以识别并以gbk格式打开，免去了再开一个Excel的烦恼 缺点： 远程连接好像没有Vscode那么方便，不过也许是我学识尚浅 确实没有Vscode连接那么方便，需要下载专业版Pycharm Git操作没有Vscode简洁，此外整体的布局也很拥挤，是因为Pycharm功能更多更完善的原因吧 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:13 "},"python_Package相关.html":{"url":"python_Package相关.html","title":"创建Package并上传至Pypi","keywords":"","body":"将自己的工作，构建为python的Package并上传至PYPI，使得其他开发者可以通过pip安装并使用。这是我一直想做的事情，最近我成功将微博数据采集项目封装并上传至PYPI。为使得后续维护工作顺利开展，并方便上传新的Package，特此记录工作要点。 如何将项目组织成Package 最重要的两个点就是__init__.py文件和相对引用 首先我展示目前的Package-dev目录 D:PackageName_dev │ .gitignore │ LICENSE │ list.txt │ pyproject.toml │ README.md │ ├─dist │ EuclidSearchPackage-0.5.0-py3-none-any.whl │ EuclidSearchPackage-0.5.0.tar.gz │ └─src ├─EuclidSearchPackage │ │ __init__.py │ │ │ ├─Demo │ │ │ WeiboClassV2.py │ │ │ WeiboClassV3.py │ │ │ __init__.py │ │ │ ├─Utils │ │ │ EuclidDataTools.py │ │ │ EuclidDataTools_test.py │ │ │ MongoClient.py │ │ │ Set_header.py │ │ │ Utils.py │ │ │ __init__.py │ │ │ ├─WeiboSearch │ │ │ Get_item_url_list.py │ │ │ Get_longTextContent.py │ │ │ Get_single_weibo_data.py │ │ │ Get_single_weibo_data_async.py │ │ │ Get_single_weibo_details.py │ │ │ Get_user_all_weibo.py │ │ │ Get_user_info.py │ │ │ Set_cookie.py │ │ │ __init__.py │ │ │ ├─EuclidSearchPackage.egg-info │ dependency_links.txt │ PKG-INFO │ SOURCES.txt │ top_level.txt │ └─Test │ cookie.txt │ DemoTest.py │ test.csv │ Test.py │ WeiboClassV2.py 一级目录说明 可以看到dev一级路径下有 src: 开发代码将写在这个文件夹下，后一节将展开讲解 dist：当package被正式build时，该目录被自动创建，并生成whl文件在此目录下 pyproject.toml：软件包架构参数设定，建议按照官方建议撰写 README.md：说明文档，将同步到PYPI的项目介绍中，例如project description LICENSE：版权信息，可以按照网上的教程选择 .gitignore：git控制中的ignore，如果不使用git可以忽略 scr说明 src下有三个文件夹 EuclidSearchPackage：包里面的程序，当包发布后，包的内容就是此文件夹中的文件 EuclidSearchPackage.egg-info：当package被正式build时，该目录被自动创建，将存储info Test：非必须，可以用于模拟package被安装后的调用过程，作为测试 关于__init__.py 我们提取package的部分来看，如何写__init__.py ├─Demo │ │ WeiboClassV2.py │ │ WeiboClassV3.py │ │ __init__.py 这是package中的一个subpackage，名字为demo，下有三个文件，其中WeiboClassV2.py和WeiboClassV3.py是代码，__init__.py的内容为： from .WeiboClassV2 import WeiboClassV2 from .WeiboClassV3 import WeiboClassV3 简单来说init的作用就是初始化，在调用时，init会被首先执行，将WeiboClassV2和WeiboClassV3调入代码空间，使其可以被调用。需要注意的是相对位置的引用规则，即得加一个. 下面展示一个完整的__init__.py，变量__all__展示了，使用import *能被调用的方法或变量 from .Get_item_url_list import Get_item_url_list from .Get_user_info import Get_user_info from .Set_cookie import Set_cookie from .Get_single_weibo_data import Get_single_weibo_data from .Get_user_all_weibo import Get_user_all_weibo from .Get_single_weibo_data_async import Get_single_weibo_data_async from .Get_longTextContent import Get_longTextContent # 未完成 from .Get_single_weibo_details import Get_single_weibo_details __all__ = ['Get_user_all_weibo', 'Get_user_info', 'Set_cookie', 'Get_item_url_list', 'Get_single_weibo_data', 关于相对位置引用 在上一节的init写法中已经讲到了得加.，但是有一种情况是需要另外注意的，提取目录的部分进行说明： ├─Utils │ │ MongoClient.py │ │ Set_header.py │ │ __init__.py ├─WeiboSearch │ │ Get_item_url_list.py 具体场景为，在Get_item_url_list.py中需要调用Set_header.py 中的Set_header函数，那么需要 首先确保__init__.py中 from .Set_header import Set_header from .Set_header import * # 二选一，更推荐上面的写法 在Get_item_url_list.py中，使用如下方式引用Set_header函数 from ..Utils import Set_header 关于Test目录 此目录可以模拟包被安装后的使用过程，不过导入还是有些微差别，需要加上src.： import src.EuclidSearchPackage as ESP 后续的写法就完全一致了，建议发布前都测试一下。 打包发布Package 建议参照官方教程，总结起来有这么关键的几步： Creating pyproject.toml，即软件包架构参数设定，建议按照官方建议撰写 Creating README.md：代码说明，建议还是写清楚，会同步到PYPI的project description Creating a LICENSE：官方的示例 build：构建包python -m build，生成的文件会在dist目录下，版本迭代后，记得删掉旧版本 upload：将package上传至PYPI，python twine upload dist/*，需要输入用户名和密码，如果没有账号需要提前创建。 更新维护 建议同步将package_dev开源至github，方便接受issue，对package更新后，记得更新版本号，然后重新build上传就好。 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"R语言操作.html":{"url":"R语言操作.html","title":"R语言","keywords":"","body":"用于记录R语言的一些语法操作，主要为研究生期间的课程所学 基础操作 数据读写 读取csv文件 data 读取txt数据 data 数据切片 使用subset对数据框进行切片 onedayData 聚合查询 类似于python的groupby ConfirmedCovidCases 随机数 设置随机种子 set.seed(1234) 随机生产序列 x1 库地址 ggplot2 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:13 "},"R英文分词.html":{"url":"R英文分词.html","title":"英文分词","keywords":"","body":"使用R语言进行分词，并进行简单分析 使用tm包词频统计 文本预处理 tolower函数将所有英文字母转换为小写字母，removeNumbers函数将数字删除，removePunctuation函数将标点符号删除，removeWords函数将停用词删除，stripWhitespace函数将多余的空格删除，stemDocument函数将单词还原为其词根。 词频统计 使用TermDocumentMatrix函数将语料库对象转换为文档-单词矩阵，然后使用findFreqTerms函数找出出现频率最高的单词，使用rowSums函数统计每个单词出现的总次数。 代码实现 将分词和词频统计两部分封装成函数get_word_counts，注意传入参数text为数据库的文本列，例如tweets$text library(tm) get_word_counts demo调用，数据集链接 tweets 使用wordcloud绘制词云 library(wordcloud) # 获取前40个高频单词 top_words Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:13 "},"R回归分析.html":{"url":"R回归分析.html","title":"回归分析","keywords":"","body":"R语言回归分析相关流程 数据预处理 中心化标准化 data 变量相关性检验 使用Hmisc library(Hmisc) rcorr(as.matrix(data), type = 'pearson') R 使用psych library(psych) corr.test(data,use=\"complete\") 热力图 library(Hmisc) R 使用ggplot绘制热图 library(Hmisc) R 偏相关系数 在多要素所构成的系统中，当研究某一个要素对另一个要素的影响或相关程度时，把其他要素的影响视作常数（保持不变），即暂时不考虑其他要素影响，单独研究两个要素之间的相互关系的密切程度，所得数值结果为偏相关系数 计算偏相关系数并绘图 library(corpcor) cor2pcor(R) # 计算得到偏相关阵 library(corrplot) corrplot(cor2pcor(R), method=\"color\", addCoef.col='grey', tl.col='black') # 热力图 建立模型 最小二乘回归 model 计算杠杆值 hii 计算模型残差 SSE 回归模型检验 显著性检验 summary(model)$r.squared # R-square summary(model)$adj.r.squared # Adjusted R-square sum((result - mean(result))^2) # SSR sum((data$y - result)^2) # SSE sum((data$y - mean(data$y))^2) # SST, and SST = SSR + SSE plot(fitted(model), model$residuals, pch = 19, xlab = \"fitted values\",ylab = \"residuals\") # 残差图 模型分析 点预测 mo 区间预测 confidence_interval 绘制区间图 # 对齐数据顺序 data_order 开始绘图 plot(data$x, data$y, xlab=\"x\", ylab=\"y\", pch = 16) # 绘制轮廓 polygon(c(data_order$x,rev(data_order$x)),c(prediction_interval_order[,2],rev(prediction_interval_order[,3])),col = rgb(221,234,243,max = 255),border = NA) polygon(c(data_order$x,rev(data_order$x)),c(confidence_interval_order[,2],rev(confidence_interval_order[,3])),col = \"gray\",border = NA) # 其中polygon为绘制多边形的函数，rev为排序函数 abline(mo, col=\"red\", lwd=2) points(data$x, data$y, pch = 16) 预测相关 新值预测 new Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:13 "},"R可视化.html":{"url":"R可视化.html","title":"绘图专栏","keywords":"","body":"记录R语言可视化相关的内容 散点图 plot散点图，直接使用plot plot(data$x, data$y, xlab=\"x\", ylab=\"y\", pch=16) # 参数pch设置点的类型 限制y范围 plot(ylim=c(0,2),hii_order,xlab=\"\",ylab=\"\",pch=16) 散点图矩阵 pairs(data, main=\"Basic Scatter Plot Matrix\") # 基础的散点图矩阵 library(car) scatterplotMatrix(data, spread=F, smoother.args=list(lty=2),regLine=T,smooth = F,main=\"Scatter Plot Matrix via car Pakage\") # 带有分布图的散点图矩阵 library(GGally) ggpairs(data = data) # 美观的变量矩阵 线图 添加回归直线 mo 坐标轴 带坐标轴的回归结果添加 x1 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:13 "},"图解中心化.html":{"url":"图解中心化.html","title":"图解中心化、标准化对回归的影响","keywords":"","body":"数值模拟：图解中心化和标准化对系数估计的影响, 一元 中心化的影响 数值模拟 x1 回归拟合 m1 图解 中心化带截距项 plot(x1, y, xlab=\"x\", ylab=\"y\", ylim=c(-8,8), xlim=c(-8,8), pch=15) # 绘制散点图 abline(h=0, v=0, lty=2) abline(reg=m1, col=\"black\", lwd=2) # 原始回归模型 points(x1.c, y, col=\"blue\", pch=17) # x 中心化后的数据 abline(reg=m2, col=\"blue\", lwd=2) # x 中心化后的回归模型, 带截距项 points(x1, y.c, col=\"red\", pch=19) # y 中心化后的数据 abline(reg=m3, col=\"red\", lwd=2) # y 中心化后的回归模型, 带截距项 points(x1.c, y.c, col=\"yellow\", pch=21) # x 和 y 均中心化后的数据 abline(reg=m4, col=\"yellow\", lwd=2) # x 和 y 均中心化后的回归模型, 带截距项 X中心化不带截距项 plot(x1, y, xlab=\"x\", ylab=\"y\", ylim=c(-8,8), xlim=c(-8,8), pch=15) # 绘制散点图 abline(h=0, v=0, lty=2) abline(reg=m1, col=\"black\", lwd=2) # 原始回归模型 points(x1.c, y, col=\"blue\", pch=17) # x 中心化后的数据 abline(reg=m5, col=\"blue\", lwd=2) # x 中心化后的回归模型, 不带截距项 legend(\"topleft\",inset = 0.04,c('m1','m6'),pch = c(15,17),col = c(\"black\",\"blue\")) Y中心化不带截距项 plot(x1, y, xlab=\"x\", ylab=\"y\", ylim=c(-8,8), xlim=c(-8,8), pch=15) # 绘制散点图 abline(h=0, v=0, lty=2) abline(reg=m1, col=\"black\", lwd=2) # 原始回归模型 points(x1, y.c, col=\"red\", pch=19) # y 中心化后的数据 abline(reg=m6, col=\"red\", lwd=2) # y 中心化后的回归模型, 不带截距项 legend(\"topleft\",inset = 0.04,c('m1','m6'),pch = c(15,19),col = c(\"black\",\"red\")) X中心化、Y中心化不带截距项 ## 中心化对回归的影响 ## plot(x1, y, xlab=\"x\", ylab=\"y\", ylim=c(-8,8), xlim=c(-8,8), pch=15) # 绘制散点图 abline(h=0, v=0, lty=2) abline(reg=m1, col=\"black\", lwd=2) # 原始回归模型 points(x1.c, y.c, col=\"yellow\", pch=21) # x 和 y 均中心化后的数据 abline(reg=m7, col=\"yellow\", lwd=2) # x 和 y 均中心化后的回归模型, 带截距项 legend(\"topleft\",inset = 0.04,c('m1','m7'),pch = c(15,21),col = c(\"black\",\"yellow\")) m2与m4的关系：将m2平移至过原点, 即得m4 m3 m4 m5得到相同的拟合直线, 但m4与m3 m5对应的响应变量不同, 是针对不同数据得到的拟合直线. 事实上, 当y的均值离0较远时, m6得到的拟合直线的效果往往较差, 这是因为假定的模型(不含截距项)与真实的模型(含有截距项)相差较远. 标准化带截距项 plot(x1, y, xlab=\"x\", ylab=\"y\", ylim=c(-8,8), xlim=c(-8,8), pch=15) # 绘制散点图 abline(h=0, v=0, lty=2) abline(reg=n1, col=\"black\", lwd=2) # 原始回归模型 points(x1.s, y, col=\"blue\", pch=17) # x 中心标准化后的数据 abline(reg=n2, col=\"blue\", lwd=2) # x 中心标准化后的回归模型, 带截距项 points(x1.s, y.s, col=\"red\", pch=19) # x 和 y 均中心标准化后的数据 abline(reg=n3, col=\"red\", lwd=2) # x 和 y 均中心标准化后的回归模型, 带截距项 legend(\"topleft\",inset = 0.04,c('n1','n2','n3'),pch = c(15,17,19),col = c(\"black\",\"blue\",\"red\")) 标准化不带截距项 plot(x1, y, xlab=\"x\", ylab=\"y\", ylim=c(-8,8), xlim=c(-8,8), pch=15) # 绘制散点图 abline(h=0, v=0, lty=2) abline(reg=n1, col=\"black\", lwd=2) # 原始回归模型 points(x1.s, y, col=\"blue\", pch=17) # x 中心标准化后的数据 abline(reg=n4, col=\"blue\", lwd=2) # x 中心标准化后的回归模型, 带截距项 points(x1.s, y.s, col=\"red\", pch=19) # x 和 y 均中心标准化后的数据 abline(reg=n5, col=\"red\", lwd=2) # x 和 y 均中心标准化后的回归模型, 带截距项 legend(\"topleft\",inset = 0.04,c('n1','n4','n5'),pch = c(15,17,19),col = c(\"black\",\"blue\",\"red\")) n2与n4的关系：将n2平移至过原点, 即得n4 n3 n5得到相同的拟合直线 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"研究生课程相关.html":{"url":"研究生课程相关.html","title":"课程知识点","keywords":"","body":"记录一些研究生课程、及其他方面的理论知识 多元统计 回归分析 广义线性模型 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"回归分析知识点.html":{"url":"回归分析知识点.html","title":"回归分析","keywords":"","body":"此章节将记录回归分析课程中的知识点，供复习使用。 一元线性回归模型 模式表示方法 一元线性理论回归模型 $$ \\begin{aligned} y = \\beta_0 + \\beta_1x + \\varepsilon\\ E(\\varepsilon|X) = 0\\ var(\\varepsilon|X)=\\sigma^2 \\end{aligned} $$ 另一种表示方法 $$ \\begin{aligned} E(y|x)=\\beta_o+\\beta_1x\\ var(y|x) = \\sigma^2 \\end{aligned} $$ 待估参数为：截距项$$\\beta_0$$，斜率$$\\beta_1$$，方差$$\\sigma^2$$ 误差随机项$$\\varepsilon_i$$Gauss-Markov条件 高斯马尔科夫条件是最小二乘(OLS)的前提 $$ \\begin{aligned} E(\\varepsilon_i)=0\\ Var(\\varepsilon_i) = \\sigma^2\\ Cov(\\varepsilon_i,\\varepsilon_j)=0,i\\ne j \\end{aligned} $$ 参数估计及其性质 最小二乘估计 经验回归方程通过数据的重心$$(\\bar x,\\bar y)$$ $$ \\begin{aligned} \\hat\\beta0 = \\bar y -\\hat\\beta_1 \\bar x\\ \\hat\\beta_1 = L{xy} /L{xx}\\ 其中\\ L{xx} = \\sum{i=1}^n (x_i - \\bar x)^2 = \\sum{i=1}^n xi^2 - n(\\bar x)^2\\ L{xy} = \\sum{i=1}^n (x_i - \\bar x)(y_i- \\bar y) =\\sum{i=1}^n x_i y_i - n \\bar x \\bar y \\end{aligned} $$ $$\\beta_1$$与相关系数的关系 极大似然估计 仅考虑$$\\beta_0,\\beta_1$$估计时，与最小二乘原理相同。进一步对$$\\sigma^2$$的估计为 $$ \\sigma^2 = \\frac{1}{n} \\sum{i=1}^n(y_i - \\hat y_i)^2 = \\frac{1}{n}\\sum{i=1}^ne_i^2 $$ 但是这是一个有偏估计量，所以一般采用调整后的无偏估计量作为方差的估计具体将在残差性质中证明 $$ \\begin{aligned} E(\\sum ei^2) = (n-2)\\sigma^2\\ \\hat \\sigma^2 = \\frac{1}{n-2}\\sum{i=1}^n(y_i - \\bar y)^2 \\end{aligned} $$ 最小二乘估计的性质 线性性 $$\\beta0,\\beta_1$$是$$y_1,y_2,...,y_n$$的线性组合： $$ \\begin{aligned} \\hat \\beta_1 = \\sum{i=1}^n\\frac{(xi - \\bar x)}{L{xx}}yi\\ \\hat \\beta_0 = \\sum{i=1}^n[\\frac{1}{n}-\\frac{(xi - \\bar x)\\bar x}{L{xx}}]yi \\end{aligned} $$ 给定$$x_i$$,拟合值$$\\hat y_i$$可以表示为$$y_1,y_2,...,y_n$$的线性组合 $$ \\begin{aligned} \\hat y_i = \\hat \\beta_0 +\\hat \\beta_1 x_i = \\sum{j=1}^n [\\frac{1}{n}+\\frac{(xi - \\bar x)(x_j - \\bar x)}{L{xx}}]yj \\doteq \\sum{j=1}^n h{ij}y_j \\end{aligned} $$ 残差$$e_i$$可以表示为$$y_1,y_2,...,y_n$$的线性组合 $$ e_i = y_i - \\hat y_i = y_i -\\sum{j=1}^n h{ij}y_j $$ 注意，$$h{ij}=h_{ji}$$是只和$$x$$有关的量。 估计量的期望、方差、协方差 截距项$$\\beta_0$$的估计量 $$ \\begin{aligned} \\hat \\beta0 \\sim N(\\beta_0,[\\frac{1}{n}+\\frac{\\bar x ^2}{L{xx}}]\\sigma^2) \\end{aligned} $$ 斜率项$$\\beta_1$$的估计量 $$ \\hat \\beta1 \\sim N(\\beta_1,\\frac{\\sigma^2}{L{xx}}) $$ 估计量的协方差 $$ Cov(\\hat \\beta0,\\hat \\beta_1) = -\\frac{\\bar x}{L{xx}}\\sigma^2 $$ 回归方程显著性检验 回归系数的显著性检验（t检验） 构造t统计量，其中$$\\hat \\sigma^2$$为$$\\sigma^2$$的无偏统计量 $$ t = \\frac{\\hat \\beta1 -0}{\\sqrt{\\hat \\sigma^2/L{xx}}} $$ 回归方程的显著性检验（F检验） 构造F统计量服从卡方分布，右侧检验，越大越拒绝 $$ F = \\frac {SSR/1}{SSE/n-2}\\其中\\ SST = \\sum{i=1}^n(y_i-\\bar y)^2、SSR = \\sum{i=1}^n(\\hat yi - \\bar y)^2，SSE = \\sum{i=1}^n(\\hat y_i-y_i)^2 $$ 残差及其性质 残差$$e_i$$可以表示为$$y_1,y_2,...,y_n$$的线性组合 $$ ei = y_i - \\hat y_i = y_i -\\sum{j=1}^n h{ij}y_j\\其中\\ h{ij} = \\frac{1}{n}+\\frac{(xi - \\bar x)(x_j - \\bar x)}{L{xx}} $$ 残差$$e_i$$可以看做随机变量$$\\varepsilon$$的非独立样本 残差的协方差 $$ 当i=j时\\ Cov(ei,e_j)=(1-h{ii})\\sigma^2 \\ 当i \\ne j时\\ Cov(ei,e_j)=-h{ij}\\sigma^2 $$ 残差平方和的期望 $$ E(\\sum ei^2) = \\sum E(e_i^2) = \\sum Var(e_i) = \\sum (1-h{ii})\\sigma^2 = (n - \\sum h_{ii})\\sigma^2 = (n-2)\\sigma^2 $$ 杠杆值$$h_ij$$ 度量了自变量空间中的第$$i$$个数据偏离数据中心的程度 $$ \\sum{i=1}^n h{ii} = 2,即tr(H) = 2\\ \\sum{j=1}^n h{ij}^2 = h{ii}\\ \\sum{k=1}^n h{ik}h{kj} = h_{ij} $$ 以上性质在多元中，联系帽子矩阵$$H$$可方便理解 区间预测 新值预测 $$ \\hat y0 = \\sum{j=1}^n h{0j}y_j \\sim N(\\beta_0 + \\beta_1x_0,\\sum{j =0}^n h{0j}^2 \\times\\sigma^2) = N(\\beta_0 + \\beta_1x_0,h{00}\\times\\sigma^2)\\ y0 - \\hat y_0 \\sim N(0,(1+h{00})\\sigma^2)\\ t =\\frac{y0 - \\hat y_0}{\\sqrt{(1+h{00})\\sigma^2}}\\sim t(n-2) $$ 故$$y0$$置信水平为$$1-\\alpha$$的预测区间为$$\\hat y_0 \\pm t{\\alpha/2}\\times \\sqrt{(1+h{00})}\\sigma$$，$$h{00}$$称为新值$$x_0$$的杠杆值 $$ h{00} = \\frac{1}{n}+\\frac{(x_0-\\bar x)^2}{L{xx}} $$ 样本量越大，$$L{xx}$$越大，$$x_0$$越靠近$$\\bar x$$，则$$h{00}$$越小，区间长度越短，预测精度越高 新值平均值的预测 因为$$E(\\hat y_0)$$为常量，所以方差为0 $$ y0 - E(\\hat y_0) \\sim N(0,h{00}\\times\\sigma^2)\\ t =\\frac{y0 - \\hat y_0}{\\sqrt{h{00}\\times \\sigma^2}}\\sim t(n-2) $$ 多元线性回归 矩阵表示 $$ Y = X\\beta + \\varepsilon\\ E(\\varepsilon) = 0\\ Var(\\varepsilon) = \\sigma^2 I_n $$ 误差随机项$$\\varepsilon$$Gauss-Markov条件 $$ E(\\varepsilon) = 0\\ Var(\\varepsilon) = \\sigma^2I_n $$ 随机误差项满足正态分布假设，矩阵表示形式为$$\\varepsilon\\sim N(0,\\sigma^2I_n)$$，此时$$Y\\sim N(X\\beta,\\sigma^2I_n)$$ 参数估计及其性质 目标函数$$Q(\\hat \\beta)$$最小 $$ Q(\\hat \\beta) = (Y - X\\beta)^T(Y-X\\beta)\\最小得到 \\\\hat \\beta =(X^TX)^{-1}X^TY $$ 拟合值和残差的矩阵表示 引入帽子矩阵（投影矩阵）$$H=X(X^TX)^{-1}X^T$$的概念，其各元素为$$h_{ij}$$，即为一元回归中的杠杆值 $$ \\hat Y = X \\hat \\beta = X(X^TX)^{-1}X^TY \\doteq HY \\ e = Y - \\hat Y = (I-H)Y $$ 其中$$H$$是只和$$X$$相关的量 帽子矩阵$$H$$的性质 $$H$$为对称幂等阵 $$tr(H) =\\sum_{j=1}^nhjj= p+1$$ $$rk(H) = tr(H) = p+1$$ $$I-H$$为对称幂等阵 $$rk(I-H) = n-p-1$$ 实对称幂等矩阵的特征根非0即1 方差的极大似然估计 极大似然估计量是有偏的估计 $$ \\hat \\sigma^2 = \\frac {1}{n}(Y - X\\beta)^T(Y-X\\beta) = \\frac{1}{n}e^Te $$ 无偏估计为 $$ \\hat \\sigma^2 = \\frac{1}{n-p-1}e^Te = \\frac{1}{n-p-1}Y^T(I_n-H)Y $$ 因为 $$ E(e^Te) = E(\\sum{i=1}^ne_i^2) = \\sum{i=1}^nE(ei^2) = \\sum{i=1}^nVar(e_i^2)=(n-p-1)\\sigma^2 $$ 估计量的方差矩阵 $$ Var(\\hat \\beta) = Cov(\\hat \\beta,\\hat\\beta) = \\sigma^2(X^TX)^{-1} $$ 通常$$(X^TX)^{-1}$$为非对角矩阵，即$$\\hat \\beta$$各分量间具有相关性 残差及其性质 与一元模型一致 $$ 当i=j时\\ Cov(ei,e_j)=(1-h{ii})\\sigma^2 \\ 当i \\ne j时\\ Cov(ei,e_j)=-h{ii}\\sigma^2 $$ $$Cov(e,\\hat Y) = Cov((I_n-H)Y,HY)=0$$ $$Cov(e,\\hat y_o) =Cov((I_n-H)Y,x_o(X^TX)^{-1}X^TY)=0$$ $$Cov(e,\\hat\\beta) =Cov((I_n-H)Y,(X^TX)^{-1}X^TY)=0$$ $$X^Te=0$$ X正态假设下的分布 观测Y $$ Y \\sim N(X\\beta,\\sigma^2I_n) $$ 参数估计值 $$ \\hat \\beta \\sim N(\\beta,\\sigma^2 (X^TX)^{-1}) $$ 预测值$$\\hat Y$$ $$ \\hat Y = HY\\sim N(X\\beta,\\sigma^2H) $$ 预测单值$$\\hat y_0$$ $$ \\hat y_0 = x_0^T(X^TX)X^TY\\sim N(x_0^T\\beta,\\sigma^2x_0^T(X^TX)^{-1}x_0) $$ 残差向量$$e$$ $$ e = (I_n-H)Y \\sim N(0,\\sigma^2(I_n-H)) $$ $$SSE/\\sigma^2$$ $$ \\frac{(n-p-1)\\hat\\sigma^2}{\\sigma^2}= \\frac{SSE}{\\sigma^2} = \\frac{Y^T(I_n-H)Y}{\\sigma^2} \\sim \\chi^2(n-p-1) $$ $$\\hat \\sigma^2 $$与$$\\hat \\beta$$独立 回归方程的显著性检验 F检验统计量 右侧检验，越大越拒绝，认为模型有效 $$ F = \\frac{SSR/p}{SSE/(n-p-1)} $$ SSR $$ Y^T(H-\\frac{1}{n}\\mathbf{1}_n\\mathbf{1}_n^T)Y $$ 其中$$Rank(H-\\frac{1}{n}\\mathbf{1}_n\\mathbf{1}_n^T)=p+1-1=p$$ SSE $$ Y^T(I_n-H)Y $$ 其中$$Rank(I_n-H)=n-p-1$$ SST $$ Y^T(I_n-\\frac{1}{n}\\mathbf{1}_n\\mathbf{1}_n^T)Y $$ 其中$$Rank(I_n-\\frac{1}{n}\\mathbf{1}_n\\mathbf{1}_n^T)=n-1$$ t检验 参数估计值$$\\hat\\beta\\sim N(\\beta,\\sigma^2(X^TX)^{-1})$$ 原假设下 $$ \\hat\\betaj \\sim N(0,\\sigma^2c{jj}) $$ 其中$$c_{jj}$$表示$$(X^TX)^{-1}$$第$$j+1$$个对角线上的元素 t统计量 $$ tj = \\frac{\\hat \\beta_j}{\\sqrt{c{jj}}\\sigma} \\sim t(n-p-1) $$ 拟合优度$$R^2$$ $$R^2$$表示因变量的变异中，自变量可以解释的比例 $$ R^2 = \\frac{SSR}{SST} $$ 样本复相关系数 $$ R = \\sqrt{R^2} $$ 自由度调整后的$$R^2$$ $$ R_a^2 = 1-\\frac{n-1}{n-p-1}(1-R^2) $$ 区间预测 新值预测 构造$$t$$统计量 $$ t = \\frac{y_0-\\hat y_0}{\\sqrt{1+x_0^T(X^TX)^{-1}x_0^T}\\hat\\sigma}\\sim t(n-p-1) $$ 故$$y0$$置信水平为$$1-\\alpha$$的预测区间为$$\\hat y_0 \\pm t{\\alpha/2}(n-p-1)\\times \\sqrt{1+x_0^T(X^TX)^{-1}x_0^T}\\hat\\sigma$$ 新值平均值预测 $$ t = \\frac{\\hat y_0-E(y_0)}{\\sqrt{x_0^T(X^TX)^{-1}x_0^T}\\hat\\sigma}\\sim t(n-p-1) $$ 故$$y0$$置信水平为$$1-\\alpha$$的预测区间为$$\\hat y_0 \\pm t{\\alpha/2}(n-p-1)\\times \\sqrt{x_0^T(X^TX)^{-1}x_0^T}\\hat\\sigma$$ 中心化的影响 $$X$$中心化后，斜率的估计量不变，截距项的估计值变为$$\\bar y$$ $$X$$、$$Y$$中心化，斜率的估计量不变，截距项的估计值变为0 事实上，任何形式的坐标平移都不影响斜率项的估计值 回归诊断 残差及残差图 残差值向量 $$ e = Y - \\hat{Y} = Y - HY = (I-H)Y $$ 学生化残差 将残差进行标准化，$Var(ei) = (1-h{ii})\\sigma^2$ $$ ri = \\frac{e_i}{\\sqrt{\\hat{var(e_i)}}} = \\frac{e_i}{\\hat{\\sigma}\\sqrt{1-h{ii}}} $$ 即使$\\varepsilon \\sim N(0,1)$，$r_i$的分布依旧比较复杂，且诸$r_i$间彼此不独立 $$ E(ri)=0\\ Var(e_i)=1\\ \\rho(r_i.r_j)=\\frac{-h{ij}}{\\sqrt{1-h{ii}}\\sqrt{1-h{jj}}} $$ 但是在实际应用中，还是近似将$r_i$认为为服从标准正态分布 残差图 以某种残差为纵坐标，某一合适的量为横坐标的散点图 异常点和强影响点 异方差性及其处理 自相关性及其处理 多重共线性及其处理 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-28 10:52:30 "},"因子分析.html":{"url":"因子分析.html","title":"因子分析","keywords":"","body":"通过找公共因子，达到降维目的。如果变量间不相关，则不能使用因子分析降维。 最简单的因子模型 $$ x_i = F_i + \\varepsilon_i $$ $$F$$是对所以变量都起作用的因子，$$\\varepsilon_i$$是第$$i$$个变量特有的，即每个变量是由一个公共因子和一个特殊因子之和组成。 因子分析的目标 确定是否存在更少的不想关变量，他们能解释原始变量之间的关系 确定因子的个数 解释这些因子 计算因子得分 将因子作为进一步统计分析的变量，比如对原始变量或$$n$$个实验单元进行分类 因子分析与主成分的区别 主成分分析不是一个模型，只是变量的变换，而因子分析需要构建模型 主成分是原始变量的线性组合，而在因子分析中，原始变量是公共因子和特殊因子的线性组合 主成分和原始变量无因果关系，而因子分析中，因子是因，原始变量是果 标准化对主成分分析有影响，但是对因子分析无影响 主成分个数与原始变量个数一样（解释所有的方差），因子个数通常比原始变量个数少（达到降维目的） 主成分关心的是变量的方差，因子分析更关心变量的协方差或相关矩阵（标准化后的相关系数矩阵）的结构 主成分分析不能旋转，而因子分析通过旋转可以使得因子有很好的解释结果 因子分析结果不是唯一的，而主成分分析的结果是唯一的 主分量分析是将原始变量的方差尽量分解在前面的主分量上，因子分析是将协方差分解在因子载荷上，方差还可以放在特殊因子的方差上 正交因子模型 公共因子$$F$$间不相关，所以是正交模型；特殊因子间不相关可以更好的解释，公共的部分都被公共因子提取出来了，所以特殊因子不相关；公共因子不相关的假设有可能是不符合实际的；要根据实际问题确定是否对原始变量进行标准化。 其中$$x$$为已知的$$p$$维原始变量，$$F$$为待提取的$$m$$维因子，$$\\varepsilon$$为特殊因子。 模型中的$$\\Lambda=(\\lambdaij ){(p×m)}$$为待估计的系数矩阵，即因子载荷矩阵，$$\\lambda_{ij}$$为第$$i$$个变量在第$$j$$个因子上的载荷。 因子分析方程 因子载荷矩阵$$\\Lambda$$不唯一，模型不受量纲影响 推导过程 因子载荷矩阵是原始变量和公共因子间的协方差矩阵 原始变量的方差$$S$$可以分解在因子载荷矩阵上和特殊因子的方差上 是否标准化？ 量纲变换不影响模型，但是影响因子载荷矩阵 标准化后对因子载荷的影响 是否对原始变量标准化不影响因子分析的解释，注意要基于因子与原始变量的相关系数解释因子的含义，如果已将原始变量标准化，则可以直接基于因子载荷阵解释因子的含义 因子载荷的大小依赖量纲的选取，通常在因子分析前将数据标准化，基于相关阵进行因子分析 因子载荷矩阵不唯一 载荷矩阵不唯一使得因子旋转成为可能 好处：不能解释时可以旋转，没有旋转之前认为是没有找到真正有实际意义的因子，旋转帮助我们找到了有实际意义的因子，可以解释实际问题了。 坏处：每人得到一组解，谁来确定哪个解是有意义的？增加了人为的因素，不是仅仅由数据决定，这也是统计解决问题的特点。 正交模型中各量的统计意义 因子载荷的统计意义 因子载荷矩阵中每个元素$$\\lambda_{ij}$$的意义 变量共同度的统计意义 因子载荷矩阵每行元素平方和的含义，$$x_i$$能被公共因子解释的程度 公因子$$F_i$$的方差贡献的统计意义 因子载荷矩阵每列元素平方和的含义 因子分析方程参数估计 主分量法 主因子法 迭代主因子法 极大似然法 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"残差诊断.html":{"url":"残差诊断.html","title":"残差诊断","keywords":"","body":"残差图诊断 par(mfrow = c(2,2)) # 普通残差图 plot(fitted(model), residuals(model), xlab=\"拟合值\", ylab=\"普通残差\",pch=19) abline(h=0, lty=2) # 删除残差图 plot(fitted(model), residuals(model)/(1-hatvalues(model)), xlab=\"拟合值\", ylab=\"删除残差\", pch=19) abline(h=0,lty=2) # 学生化残差图 plot(fitted(model), rstandard(model), xlab=\"拟合值\", ylab=\"学生化残差\", ylim=c(-3.5,3.5), pch=19) abline(h=0, lty=2) # 删除学生化残差图 plot(fitted(model), rstudent(model), xlab=\"拟合值\", ylab=\"删除学生化残差\", ylim=c(-3.5,3.5), pch=19) abline(h=0, lty=2) 使用Plot做回归诊断图 有无非线性关系 plot(model,which=1) 残差是否正态分布 plot(model, which=2) 是否有异方差 plot(model, which=3) 查看强影响点 plot(model, which=4) Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"异方差.html":{"url":"异方差.html","title":"异方差检验","keywords":"","body":"等级相关系数诊断 cor.test(mydata$x, abs(residuals(model)), method=\"spearman\", alternative=\"two.sided\") 输出 Spearman's rank correlation rho data: mydata$x and abs(residuals(model)) S = 1424, p-value = 0.002504 alternative hypothesis: true rho is not equal to 0 sample estimates: rho 0.5653236 G-Q检验 library(lmtest) gqtest(model, order.by = ~data$CDA, data =NewData, fraction = 30) 输出 Goldfeld-Quandt test data: model GQ = 2.9526, df1 = 39, df2 = 39, p-value = 0.0005143 alternative hypothesis: variance increases from segment 1 to 2 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"爬虫相关.html":{"url":"爬虫相关.html","title":"网络爬虫","keywords":"","body":"这里存储一些爬虫需要注意的点 爬虫不能忘记的几个点 标签查找要使用稳定的方法 selenium设置隐式等待优于sleep Cookie 将cookie设置另做函数是一种推荐的做法 def set_headers(cookieFileName): \"\"\" 设置请求头，主要是cookie的设置，需要登录企查查后，进入开发者工作获取。 :param cookieFileName: 存储cookie的文件例如：'cookie.txt',str :return: 请求头header,dict \"\"\" with open(cookieFileName, 'rt', encoding='utf-8') as f: cookie = f.read().strip() header = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:61.0) Gecko/20100101 Firefox/61.0', 'Cookie': cookie } print('headers设置成功') return header 爬外网时需要注意自己的梯子 requests设置代理 import requests #ssr配置代理，端口查看梯子软件 proxies={'http': 'http://127.0.0.1:10619', 'https': 'http://127.0.0.1:10619'} response = requests.get(Url,proxies=proxies) html = response.content.decode('utf-8', 'ignore') soup = BeautifulSoup(html, features=\"lxml\") selenuim设置代理 from selenium.webdriver import Chrome, ChromeOptions # 导入类库 option = ChromeOptions() # 初始化类 ip = \"127.0.0.1\" port = \"10619\" # 设置代理 option.add_argument(\"--proxy-server=http://{}:{}\".format(ip, port)) driver = Chrome(options=option) # 模拟开浏览器 driver.get(Url) # 跳转网址 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"BeatifulSoup使用.html":{"url":"BeatifulSoup使用.html","title":"BeautifulSoup","keywords":"","body":"beautifulsoup包的主要作用是将str格式的网页源码转换成soup格式，soup格式可以通过类似json格式的方式进行索引。 主要流程介绍 解析网页源码 import requests from bs4 import BeautifulSoup # 导入类库 response = requests.get(Url, headers=headers, timeout=60) # 使用request获取网页 html = response.content.decode('utf-8', 'ignore') # 将网页源码转换格式为html soup = BeautifulSoup(html, features=\"lxml\") # 构建soup对象，\"lxml\"为设置的解析器 结合selennium处理数据 idList = driver.find_elements_by_class_name('list_con') # driver查找元素 soup = BeautifulSoup(idList[0].get_attribute('outerHTML')) # 获取元素的内容彬转换为soup对象 查找标签 find_all soup.find_all('div', \"classname\") # 查找soup中Class属性为\"classname\"的\"div\"标签 指定其他属性 soup.find_all('div', {\"id\":\"idName\"}) # 查找soup中id属性为\"idName\"的\"div\"标签 使用Xpath，下一篇有正则用法 self.driver.find_elements(By.XPATH, '//*[@id=\"gs_cit-x\"]/span[1]')[0].click() 获取文本内容 text divs.text # 直接获取\"div\"标签下的文本信息 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:13 "},"Selenium爬虫相关.html":{"url":"Selenium爬虫相关.html","title":"Selenium","keywords":"","body":"为了Selenium方法的成功使用，必须保证ChromeDriver安装版本与Chrome版本匹配。当然你也可以使用其它浏览器，个人选择。 这是ChromeDriver的镜像下载地址，更新浏览器后记得更新ChromeDriver，顺便我个人记录一下，我的ChromeDriver装在C:\\Program Files (x86)\\Google\\Chrome\\Application 主要流程讲解 1、控制开启浏览器 from selenium.webdriver import Chrome, ChromeOptions # 导入类库 option = ChromeOptions() # 初始化类 option.add_experimental_option(\"excludeSwitches\", ['enable-automation', 'enable-logging']) # 添加参数 driver = Chrome(options=option) # 模拟开浏览器 driver.get('https://m.xiaozhu.com/#') # 跳转网址 myDriver.maximize_window() # 最大化窗口 2、获取对应元素 driver.find_elements_by_class_name('list_con') # 通过class的方式获取，也可以使用其他方式 find_elements(By.XPATH,\"//*[contains(@href, 'pdf')]\").get_attribute('href') selenium更新后，之前的获取元素的方式发生了改变，主要差异为引入了By,其他的参数直接点开By查看即可 from selenium.webdriver.common.by import By driver.find_elements(By.CLASS_NAME, 'list_con') 同样可以使用Xpath获取元素，语法为//节点名[starts-with(@元素名, \"相同部分\")] //div[starts-with(@id,'ma')] # 选取id值以ma开头的div节点 //div[contains(@id,'ma')] # 选取id值含有ma的div节点 //div[contains(@id,'ma') and contains(@id,'in')] # 选取id值包含ma和in的div //div[contians(text(),'ma')] # 选取节点文本包含ma的div节点 3、处理元素数据 我习惯于使用BeatifulSoup处理，当然也可以使用selenium套件处理，等有空我再学习一下补上 idList = driver.find_elements_by_class_name('list_con') soup = BeautifulSoup(idList[0].get_attribute('outerHTML')) # 转换为soup对象 divs = soup.find_all('div', \"list clearfix carnival_item\") # 找到对象中数据列表 element.click() # 点击元素 4、设置等待 from selenium.webdriver.support.wait import WebDriverWait WebDriverWait(myDriver, 10).until(lambda driver: driver.find_element(By.CLASS_NAME, 'bicon.bar-icon-fp')) 5、托管指定端口的浏览器 对于知乎这种网站，使用selenium控制开启一个浏览器往往会被识别，所以需要我们配置一个浏览器（进行登录等常规操作）后，再使用代码直接托管，具体流程如下： 将Chrome发送到桌面快捷方式，并设置其端口和缓存文件路径 目标处填入“程序路径 端口设置 文件路径”，具体如下 \"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\" --remote-debugging-port=9222 --user-data-dir=\"D:\\Euclid_Jie\" 使用Python接管浏览器 from selenium import webdriver options = webdriver.ChromeOptions() options.add_experimental_option(\"debuggerAddress\", \"127.0.0.1:9222\") # 接管 driver = webdriver.Chrome(options=options) # 设置参数 driver.get(Url) # 跳转网页 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"Urllib3相关.html":{"url":"Urllib3相关.html","title":"Urllib3","keywords":"","body":"作为Requests和Selenium的补充，简单记录其用法 Urllib3的请求方法 Get请求 import urllib3 http = urllib3.PoolManager() # 创建PoolManager对象生成请求 response = http.request('GET', 'http://www.baidu.com') # get方式请求 print(response.status,response.data.decode('utf-8')) # 获得状态码, html源码(utf-8解码) Post请求 import urllib3 import json http = urllib3.PoolManager() headers = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64)', 'Host':'httpbin.org'} data = {'word':'hello'} data = json.dumps(data).encode() # json.dumps方法可以将python对象转换为json对象 response = http.request('POST','http://httpbin.org/post',body=data, headers=header) print(response.status,response.data.decode('utf-8')) Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"IP代理介绍.html":{"url":"IP代理介绍.html","title":"IP代理池","keywords":"","body":"IP代理作为反反爬的一个有效途径，面对一些基础的反爬网站，学会使用IP代理非常有必要 目前我使用来着GitHub上一个开源项目抓取公开IP的项目构建IP池子，再次感谢开源博主，下面进行介绍 Clone项目 git clone git@github.com:jhao104/proxy_pool.git 确认安装Redis并开启服务 Redis是一个用于存储键值对的简单数据库，可以从GitHub下载，也可以上官网，安装完成后，运行redis-cli.exe，如显示127.0.0.1:6379>，说明安装成功，并在指定端口开启服务，进一步可以配置密码，具体教程 redis-cli.exe -h 127.0.0.1 -p 6379 config set requirepass 123456 # 设置密码为123456 进行项目配置 配置redis数据库密码 DB_CONN = 'redis://:pwd@127.0.0.1:8888/0' # pwd改为自己的密码123456 启动IP抓取 python proxyPool.py schedule # 运行后开始抓取IP并存入数据库 调用IP池 python proxyPool.py server # 启动API服务接口,端口为http://127.0.0.1:5010 具体调用规则包括 api method Description params / GET api介绍 None /get GET 随机获取一个代理 可选参数: ?type=https 过滤支持https的代理 /pop GET 获取并删除一个代理 可选参数: ?type=https 过滤支持https的代理 /all GET 获取所有代理 可选参数: ?type=https 过滤支持https的代理 /count GET 查看代理数量 None /delete GET 删除代理 ?proxy=host:ip 调用实例（记得先开启API服务） # 从数据库调用IP def get_proxy(): return requests.get(\"http://127.0.0.1:5010/get/\").json() # 删除数据库中IP def delete_proxy(proxy): requests.get(\"http://127.0.0.1:5010/delete/?proxy={}\".format(proxy)) # 使用代理IP发起请求 def getResponse(URL, header): retry_count = 5 proxy = get_proxy().get(\"proxy\") while retry_count > 0: try: response = requests.get(URL, headers=header, timeout=60, proxies={\"http\": \"http://{}\".format(proxy)}) # 使用代理访问 return response except Exception: retry_count -= 1 # 删除代理池中代理 delete_proxy(proxy) return None Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:13 "},"Git相关.html":{"url":"Git相关.html","title":"Git","keywords":"","body":"记录使用Git过程中的总结，主要包括Git命令，GIt与各种IDE的配置，Git与GitHub远程仓库连接 使用GitBash Git配置 Git官网下载并安装，配置邮箱、 配置邮箱和姓名 git config --global user.email \"youremail\" git config --global user.name \"yourname\" 查看邮箱和姓名 git config --global user.email git config --global user.name Git基础命令 初始化一个仓库 git init 查看远程信息 git remote -v # 查看远程仓库地址 git remote # 查看远程仓库分支 git remote show origin # 查看某个分支的具体信息 储存 不常用，主要是为了处理冲突 git stash save \"本地缓存内容标识\" # 创建储存 git stash list # 查看有哪些储存 git stash clear # 清除所有储存 git stash push -m \"test stash\" -p # -p进入交互式窗口, 指定部分文件的部分内容进行stash 添加文件 git add git add . # 添加所有新增文件 查看被管理的所有文件 git ls-files 查看是否有变动 git status git status -s # 简要查看 git diff # 查看具体文件内容变化 提交 与Pycharm不同，提交前都需要add git commit -m \"commit by bash\" git commit --amend -m \"commit by bash\" # 修正提交 绑定远程仓库，需要先配置SSH并在远程创建好仓库 git remote add origin git@github.com:[yourGitHubName]/[yourRepositories].git 或者请在GitHub创建完仓库后，自己观察页面，上述代码可以直接复制到 推送 如果远程没有这个分支，第二种方式 git push git push --set-upstream github dev/jie/htsec_feature 查看提交记录 git log Git显示中文乱码 step1设置config中的引用路径 git config --global core.quotepath false 将终端设置为utf-8编码 step2在git bash的界面中右击空白处，弹出菜单，选择选项->文本->本地Locale，设置为zh_CN，而旁边的字符集选框选为UTF-8。 Git使用新设备打开时，无法显示提交记录 git config --global --add safe.directory F:/GitHub/my-project git config --global --add safe.directory * Git无法Push，显示超时 Failed to connect to github.com port 443:connection timed out 需要删除git的全局代理后重新Push git config --global --unset http.proxy git config --global --unset https.proxy 有时候是因为SSL证书问题，需执行 git config --global http.sslVerify \"false\" 一般来说，如果实在解决不了的话，可以挂梯子后使用github desktop解决 建议从以下几个方面排查 检查协议 一般远程仓库的连接有两种方式，git或者http，直接检测远程链接即可 git remote -v 返回值开头是啥就是啥协议 不同协议超时有不同的排除流程 git对应的是ssh协议，检查自己的电脑的ssh私钥和github网站上的公钥是否配置好 http协议则是因为墙，试试代理 建议使用git ssh协议，兼容性更好 使用Pycharm 创建Git仓库 本地创建 Pycharm的VCS支持一键创建，就没啥好说的了，一般情况下，是需要使用git命令行创建的，命令好像是 git init，因为git我是好久以前就配置好了的，ssh那些都弄好了，所以就记得不太清楚了，在此就只写目前我的工作流 远程创建 此前一直使用GitHub，我也是它的忠实用户，但是无奈某些原因连接实在是不稳定，所以使用Gitee临时替代。Pycharm默认的就是GitHub，所以直接在Git窗口中登录Github账号，然后设置一下远程仓库的名字就好了，因为我已经在Github中添加了电脑的ssh，所以后续的推送都很顺利 Gitee与GitHub就是大同小异的，也就是登录、创建再提交就成 分享本地项目至远程 使用Pycharm可以很方便分享，根据提示做好仓库命名和介绍就成，另外要注意可以在在.git中的config文件中修改url为https://{username}:{password}@github{username}/project.git格式，这样的话可以避免推送的时候让你再次登录 提交与推送 这块就是勾选要提交的文件，然后写一些说明就提交就好了，一段时间后我会推送到远程 一般最开始推送的时候，我会不推送导出数据文件，以及一些设置文件，这样在最后提交项目的时候，就可以直接从GitHub或者Gitee上下载压缩包，会比较方便一点，因为确实提交项目的时候那些个人设置文件，一起运行程序的导出文件都是不必要的，会使得压缩包冗大，设置文件甚至出现不知名错误 一旦推送后，最好不要进行修正，因为会导致需要先拉取远程更新，早进行提交推送，是Git流程出现合并分支的记录（主要是不美观） 分支与合并 这个功能是我新学的，很好用，在已有稳定版本的情况下，如果想做一些尝试性的修改，那么创建一个分支，在分支上修改并测试稳定后，将分支合并到原分支上，然后删除分支就可以了，这个功能真是让我赞不绝口 删除分支 本地的分支合并后，就可以直接删除了，但是远程的分支必须保证该分支表示master（主要）分支后，才能删除 ，如果是主要分支，那需要在GitHub或者Gitee上进入该仓库进行修改后再删除 Git中的一些命名 一般命名是：仓库名/分支名，一般本地仓库不标注直接是分支名master，对应的远程仓库一般叫：origin/master，当然这些就只是名字，是为了便于我们区分，因为使用时间较短，目前我还没有形成自己的命名标准。 新分支的时候，可以根据分支需要进行命名（可以为汉字） 使用VsCode 近期的工作都在Vscode中开展, 主要是连接服务器开发, Vscode更方便, 顺便记录一下VsCode中的git管理 Git Graph插件 VsCode中热度最大的git插件应该是git lens, 但是需要收费, Git Graph是一款非常类似Pycharm自带git管理的插件 得益于Git Graph这款插件, 使得在VsCode中进行git管理, 非常方便。有非常清晰的可视化分支, 并可以通过右键方式进行诸如, checkout, merge, rebase等操作 merge or rebase ? merge 和 rebase为git中进行分支合并时非常常见的操作, 网络上各种介绍很多, 不再班门弄斧 merge 和 rebase有着不同的常见, rebase会使得git历史呈现一条直线. 尽可能整洁, 并在PR时不会冲突(因为在rebase中已经提前解决); 而merge会使得分支溯源更为容易, 会清晰记录分支的走向 对我个人而言, 公司的项目多人参与且contribute较为严格, 使用rebase; 个人项目往往各种奇思妙想比较多, 故使用merge 如何借助Git Graph进行merge ? 定心丸: 只要不push到远程, 无论何种操作都能通过reset复原, 可大胆操作 后悔药: 如果在进行merge, 或者正在解决冲突途中, 想退出, 执行git merge --abort即可 确保自己处于master分支上, 选择dev分支右键进行merge into current branch, 如果有冲突(出现合并冲突), 则解决冲突, 完成后实现merge 如何借助Git Graph进行rebase ? 与merge一样, 仍旧有定心丸和后悔药可以吃, rebase途中退出, 执行git rebase --abort即可 确保自己处于dev分支上, 选择master分支右键进行rebase current branch on Branch, 一般来说都会遇到冲突, 有冲突解决冲突即可, 完成后实现rebase 参数-i可以在交互窗口中实现pick tipis 后悔药reflog 只要没被push到远程，本地的所有操作都可以通过reflog进行恢复 查看操作历史记录 git reflog demo中展示了此repo的最近几条操作记录，寻找出你需要回退的记录对应的hash头 0c326f8 (HEAD -> dev/Jie/half_hour_features) HEAD@{0}: reset: moving to 0c326f8 6426675 HEAD@{1}: reset: moving to 6426675 cd44d32 (github/test, github/master, github/HEAD, master) HEAD@{2}: reset: moving to cd44d32 6426675 HEAD@{3}: reset: moving to HEAD 6426675 HEAD@{4}: rebase (finish): returning to refs/heads/dev/Jie/half_hour_features 6426675 HEAD@{5}: rebase (pick): add AfterFog ClimbPeak 80f1155 HEAD@{6}: rebase (squash): clear code and add unittest fe39abc HEAD@{7}: rebase (squash): # 这是一个 2 个提交的组合。 d3a491e HEAD@{8}: rebase (start): checkout master 2388e09 HEAD@{9}: rebase (finish): returning to refs/heads/dev/Jie/half_hour_features 2388e09 HEAD@{10}: rebase (pick): add AfterFog ClimbPeak 37a1991 HEAD@{11}: rebase (pick): fix distance to high 5046792 HEAD@{12}: rebase (pick): add real_stats, corr_price_volume, large_volume d3a491e HEAD@{13}: rebase (pick): clear code and add unittest 274dd93 HEAD@{14}: rebase (pick): add DeriveHalfHourFeatureFromTickTradeMinBar f9797f5 HEAD@{15}: rebase (pick): init branch 进行回退 需要说明的是，进行回退后，将回到此条操作结束后的状态 git reset --hard 6426675 其他 修改项目文件的~.git\\config中的远程地址，可以直接修改http协议为ssh协议 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-11-19 19:38:35 "},"服务器相关记录.html":{"url":"服务器相关记录.html","title":"服务器相关","keywords":"","body":"阿里云ESC 安装Python库 先安装pip wget https://bootstrap.pypa.io/pip/3.6/get-pip.py python get-pip.py 用作代理 使用tinyproxy进行ip代理 - Masako - 博客园 (cnblogs.com) centos8 tinyproxy 安装方法 (make) - songw (90条消息) 解决阿里云ECS服务器 git clone 速度慢_zwkkkk1的博客-CSDN博客 常用命令 任务管理器，查看进程 ps aux 删除文件夹 rm -rf tinyproxy/ 安装Git (90条消息) 阿里云服务器安装git详细步骤种个月亮的博客-CSDN博客阿里云 安装git 端口占用 查看进程编号，并kill netstat -anp |grep 8089 kill -9 60435 相关开发工作 部署Redis 详细见 使用Flask部署API和简单的服务 详细见 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"Linux命令.html":{"url":"Linux命令.html","title":"Linux命令","keywords":"","body":"PID 查看进程详情 ps -f -p PID 强制kill进程，如果无权限则加上sudo kill -9 PID sudo kill -9 PID 查询服务器pid对应用户 ps -f -p PID 查询pid对应的开始时间 ps -o lstart -p PID SYNC 同步数据, 已存在则跳过, rsync详情 rsync -avzu --progress source_file dest_file Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-15 10:29:54 "},"数据库相关.html":{"url":"数据库相关.html","title":"Mongo数据库","keywords":"","body":"记录MonGoDB数据库的使用，主要使用Python语言。 MongoDB安装及配置 参照最详细的Windows平台安装MongoDB教程 - TM0831 - 博客园 (cnblogs.com) 数据库启动服务 启动数据库服务 切换到mogod路径，运行mogod，并指定参数 mongod --dbpath D:\\Euclid_Jie\\DBdata 查看端口http://127.0.0.1:27017/，若显示如下内容，说明服务已经启动 It looks like you are trying to access MongoDB over HTTP on the native driver port. 关闭数据库服务 于服务窗口按下ctrl+C结束服务 使用数据库命令关闭（适用于数据库存储位置错误启动） use admin db.shutdownServer() 数据库创建及写入 使用pymongo库完成对Mongo的操作 连接数据库，其中DBName为数据库的名字，collectionName类似于表名 import pymongo def MongoClient(DBName, collectionName): # 连接数据库 myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\") mydb = myclient[DBName] # 数据库名称 mycol = mydb[collectionName] # 集合（表） return mycol # 返回一个数据表 mycol = MongoClient(\"ZhiHu\", '11月知乎舆情') 创建数据库、表 直接连接指定的库和表，如果存在则连接，如果不存在将创建，但是需要注意的是，只有当正式往表中写入数据后，表才被正式创建 写入数据 mycol.insert_one(document) # 其中document为json格式的数据 mycol.insert_many(document) # 写入多条 读取数据 Mongo数据库的数据由唯一的键_id进行索引，如果没有写入指定的_id，将自动创建索引。 mycol.distinct(\"_id\") # 获取数据表的所有id，返回格式为list mycol.find_one({'_id': id}) # 根据指定条件查询，返回数据表的其中一条数据，格式为json 修改数据（增加列） 对原始的数据进行修改或，增加列内容，逻辑为确定哪一行，然后进行何种修改 mycol.update_one({'_id': id}, {\"$set\": {'comment': comment}}) # $set为一种更新方法 筛选子集 使用distinct设置筛选条件，获取符合条件的字段 idList = mycol.distinct(\"_id\", {'天眼查Num': \"天眼查无法查询\", 'Url': {'$exists': False}}) 数据查询 查询字段非空 db.cols.find({\"name\":{\"$ne\":null}}) 查询字段包含数字 db.cols.find({\"name\":{$regex:\"\\d\"}}) db.cols..find({\"name\":{$regex:\"[0-9]\"}}) 未完待续，详见官方文档 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-06 22:39:34 "},"Redis数据库.html":{"url":"Redis数据库.html","title":"Redis数据库","keywords":"","body":"相关链接： Python使用Redis (biancheng.net) Python redis 使用介绍 | 菜鸟教程 (runoob.com) Python中使用Redis详解 - 知乎 (zhihu.com) 链接Redis 开启Redis服务 安装Redis后，执行exe程序即可开启端口 cd D:\\Program Files\\Redis redis-server.exe 关闭Redis服务 redis-server --service-stop 使用Python链接 密码：password 数据库编号（0-15）：db import redis pool = redis.ConnectionPool(host='localhost', port=6379, db=1, password=None, decode_responses=True) r = redis.Redis(connection_pool=pool) Hash命令 此系列命令用于处理Hash表，详情可参照Python操作redis系列以 哈希(Hash)命令详解（四） 哈希表的组织形式为name -> {key1:value1, key2:value1...}，如下图所示， 若value为dict，则实现了DataFrame形式的存储 其中name对应为整个DataFrame，key对应为每行数据的主键，value对应以dict格式存储的单行数据 Hset 哈希表中的字段赋值 如果name不存在，将自动生成哈希表 如果key已存在，则进行写入，并返回 如果key已存在，则进行更新，并返回0 r.hset(name=\"name\",key=\"key1\",value=\"value\") Hdel 删除哈希表中的字段 成功删除则返回1 若key不存在则删除失败，返回0 删除所有的键后，name对应的数据将消失 r.hdel(name=\"name\",key=\"key1\") r.hdel(name='name',key=*['key1','key2']) # 删除多个 Hexists 查看哈希表的指定字段是否存在 如果存在返回True，否则返回False 如果name不存在，也会返回False，故需要使用exists检测name是否存在 r.hexists('name1','key2') r.exists('name1') # 如存在返回1, 否则返回0 Hget 返回哈希表中指定字段的值 如果给定的字段或 key 不存在时，返回 None 如果name不存在，也会返回None r.hget('name3','key2') Hgetall 返回哈希表中，所有的字段和值 如果name不存在，则返回{}，其type为dict r.hgetall('name') 写入数据 写入单个键值对 r.set('webname','www.biancheng.net') 写入多个键值对 r.mset({'username':'jacak','password':'123'}) 删除 删除带指定字符的key及value # 删除带特殊符号的标题 for i in pd.DataFrame(data={'data':r.keys('*')})[pd.DataFrame(data={'data':r.keys('*')}).data.str.contains(':')].data.to_list(): r.delete(i) 修改Key r.rename('name_2', 'name_100') 在服务器部署Redis 需要注意的是，需要在ESC安全组中开启Redis服务的端口6379 (89条消息) 阿里云ECS之搭建Redis环境(八)_zheng_zq666的博客-CSDN博客 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-01 20:01:13 "},"MySQL相关.html":{"url":"MySQL相关.html","title":"MySQL","keywords":"","body":"MSQL的一级数据结构为数据库（dataBase），下级为数据表（tables）类比于MongoDB的collection MySQL 安装 参照教程(103条消息) Windows安装mysql详细步骤（通俗易懂，简单上手）_华夏之威的博客-CSDN博客 登录MySql 默认开机启动，如果没有启动服务，则使用服务台进行启动 命令行进行登录，提示输入密码后，输入密码123456 mysql -uroot -p 退出，注意MySQL的语句都是英文分号结束 exit; CMD窗口操作 数据库有关操作 1.查询时间：select now(); 2.查询当前用户：select user(); 3.查询数据库版本：select version(); 4.列出数据库：show databases; 5.选择数据库：use databaseName; 6.建立数据库：create database databaseName; 7.查看新创建的数据库信息：show create database databaseName; 8.删除数据库：drop database databaseName; 数据表有关操作 1.查看数据表存储引擎：show engines； 2.列出表格：show tables； 3.创建表：CREATE TABLE tableName( c_num int (11) not null unique primary key auto_increment, c_name varchar (50), c_contact varchar (50), c_city varchar (50), c_birth datetime not null ); 4.查看表结构：desc tableName; 5.显示表格列的属性：show columns from tableName; 6.修改字段类型：alter table tableName modify fieldName newFieldType; 7.字段改名：alter table tableName change oldFieldName newFieldName newFieldType; 8.表改名：alter table oldTableName rename newTableName; 9.复制表：create table tableName2 select * from ttableName1; 插入表中一行记录：insert into tableName values (\"value1\",\"value2\",\"value3\"......); 删除表中一行记录：delete from tableName where columnName=value; //不加where将删除全部数据 更新表中一行记录：update tableName set columnName=value where columnName=value; 查询表中所有记录：select * from tableName; 14.删除表：drop TABLE tableName; 用户操作 创建新用户 create user 'user01' @'localhost' identified by 'user01'; flush privileges; #刷新权限 删除用户 drop user ‘user01’@’localhost’; 查看所有用户 select user,host from mysql.user; MySql语法基础 MySQL 数据类型 | 菜鸟教程 (runoob.com) 语句执行顺序 FROM, including JOINs WHERE GROUP BY HAVING WINDOW functions SELECT DISTINCT UNION ORDER BY LIMIT and OFFSET 插入语句 insert 北京师范大学微博评论 (mid, time, nick_name, content, 转发数, 评价数, 点赞数) VALUE (11111,'20201201','Test','Test',1,1,1); 查询语句 select * from 北京师范大学微博评论 where 点赞数 =1 limit 10 offset 10 DataGrip使用MySql 连接数据库 由csv导入数据 长int得使用bigint类型 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:13 "},"正则表达式.html":{"url":"正则表达式.html","title":"正则表达式","keywords":"","body":"本文件中将记录一下正则表达式使用方法，以及具体案例 正则语句 元字符 [A-Z] # 匹配从A到Z的所有大写字母 [a-z] # 匹配从a到z的所有小写字母 [A-z] # 匹配大小写字母以及[,^等ASCII字符表中的任意字符 [0-9] # 任何一个数字字符 [A-Z0-9] # 匹配大写字母及数字 \\d # 任何一个数字字符，等价于[0-9] \\D # 任何一个非数字字符，等价于[^0-9] \\W # 任何一个字母数字字符（大小写均可）及下划线，等价于[a-zA-Z0-9_] \\w # 等价于[^a-zA-Z0-9_] [\\u4e00-\\u9fa5] # 匹配中文 重复匹配 + # 表示匹配一个或多个（至少一个） ? # 表示匹配零个或者一个 * # 表示有或者没有 {3} # 表示重复三次 {3-5} # 表示重复次数在3-5之间 {3，} # 表示重复三次及以上 懒惰匹配 +? # +的懒惰模式 *? # *的懒惰模式 {n,} # {n,}的懒惰模式 向前查看和向后查看 肯定式向前查看 (?=) 肯定式向后查看 (? 使用方法 获得指定字段 p = re.compile('#re#') # #re#表示正则表达式 text = p.findall(text_raw) # text_raw表示原始字符串 正则案例 匹配文章名 str = '金莲花,王华.财务共享服务中心的应用效果研究[J].会计之友,2016(05):21-24.' p = re.compile('(? 同一作者匹配 author_list = ['赵峻峰', '丁丹'] pattern = '(?=.*{})'.format(')(?=.*'.join(author)) # '(?=.*赵峻峰)(?=.*丁丹)' df_final = result[result['author'].str.contains(pattern, regex=True)] Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"GitBook相关.html":{"url":"GitBook相关.html","title":"GitBook","keywords":"","body":"GitBook在线挂载时，需要注意：章节内容第一行请勿使用标题格式，否者会造成无法显示文章内容 关于GitBook本地使用 更多教程看查看其它博主的分享 有关更多gitbook命令可使用gitbook help获取 下载GitBook并安装 需要使用node工具，没有node的需要先安装node GitBook已停止维护，需要使用旧版本的node，附V10下载链接 安装gitbook-cli，如遇到权限问题，使用管理员权限运行CMD，后再执行 npm install -g gitbook-cli 此时GitBook并未执行安装，在首次执行gitbook init后，将执行安装 书本初始化 在文件夹内下，打开cmd窗口，进行初始化 gitbook init 初始化后，目录下会出现README.md、SUMMARY.md两个文件 README.md表示对书本的介绍 SUMMARY.md用于控制书本的结构 书本构建 自动生成文件 在SUMMARY.md中写入目录后再次初始化，会自动创建文件目录及文件，例如： # SUMMARY * [Chapter1](chapter1/README.md) * [Section1.1](chapter1/section1.1.md) * [Section1.2](chapter1/section1.2.md) * [Chapter2](chapter2/README.md) 构建书本 gitbook build 会生成一个_book目录，储存html格式的书本内容 书本查看 启动serve，会返回一个本地端口，即可在浏览器中查看书本 gitbook serve 发布书本为指定格式 gitbook pdf GitHub Pages关联GitBook 为GitHub仓库设置说明文档，使用此方式非常合适且便捷 书本初始化 同样需要在项目路径启动CMD，运行gitbook init进行初始化，会自动创建README.md和SUMMARY.md 如果项目已有README.md，则只会新建SUMMARY.md，已有的READEME.md不会丢失 如果书籍的内容在项目路径下的一个文件夹内，本例中为Wiki，则直接在Wiki下进行init即可 书本构建 SUMMARY.md文件控制了整书本的结构，一般来说最多构建至二级目录 编辑完成SUMMARY.md，使用build命令构建 gitbook build Wiki docs 代码示例为：Book 相关内容全部放在Wiki目录下， 新生成的html文件将储存至docs目录下 gitbook build [书籍路径] [输出路径]，如果不指定参数，将默认使用项目目录下所有文件参与构建Book，并输出到_book目录下 需要注意的是，Wiki中的README.MD可以有 书本查看 使用serve命令可在本地400端口查看书籍 gitbook serve Wiki 代码示例为：Book 相关内容全部放在Wiki目录下 gitbook serve [书籍路径] [output] 关联GitHub Pages 首先确保此项目在GitHub上的仓库状态为公开 项目设置>Pages>Branch，设置分支及书籍html文件路径，本例中为docs 查看pages，url为：https://[GitHub用户名].github.io/[仓库名] Gitbook网页端服务 如果使用网页端的GitBook服务，可以不用安装GitBook。事实上安装GitBook会遇到很多苦难，所以直接使用GitBook网页端是一个很不错的选择。 注册GitBook账号 网站上注册一个号，可能需要梯子。 关联GitHub 关联GitHub后，可以将一本书与仓库绑定，我习惯的做法是，本地写内容，Push到GitHub上，GitBook会自动根据仓库变动，更新书本内容。 查看书本 GitBook的优秀之处就是不需要向本地一样，构建书本、启动服务，直接会有一个网址，即为书本的网页阅读模式。例如本书 注意事项 有些目录不是必须的，比如_book，不必Push至仓库，GitBook需要识别的SUMMRAY.md及其中的章节文件。 换言之，其实如果确定使用GitBook+GitHub的方式创建书本，只使用得到gitbook init。 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 18:17:26 "},"VScode.html":{"url":"VScode.html","title":"VSCode","keywords":"","body":"远程连接 VSCode连接远程主机进行开发真的很方便，下载插件Remote-SSH，然后设置Config文件，格式见下图，即可完成连接 Host github.com Hostname ssh.github.com IdentityFile \"C:\\Users\\Ouwei\\.ssh\\id_rsa\" Port 443 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-11-19 19:57:56 "},"Uqer.html":{"url":"Uqer.html","title":"Uqer","keywords":"","body":"要想使用Uqer数据库导入数据，一般要经过如下几步骤 import uqer mytoken = '' client = uqer.Client(token=mytoken) from uqer import DataAPI DataAPI.EquGet Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 18:59:24 "},"SSH介绍.html":{"url":"SSH介绍.html","title":"SSH","keywords":"","body":"SSH是一种通信验证方法，一般用来实现免登录实现GitHub与本地的通信 如果你已习惯使用Pycharm进行coding工作，那建议你直接看本文最后一行 生成公钥和私钥 需要在C:\\Users\\yourname\\.ssh目录下使用cmd窗口，如果C:\\Users\\yourname目录下没有.ssh文件夹，手动创建即可，或者直接在C:\\Users\\yourname此目录下使用cmd也可以 使用如下命令创建SSH对 ssh-keygen -t rsa -C \"azureuser@myserver\" -f \"filename\" 需要注意的是，azureuser@myserver为自己确定的标识符，一般为标记为你所要授权的平台的登录邮箱。 filename为生产的密钥对的文件名，如果需要生成多个秘钥对，请命名，以免覆盖。 生成过程中全程回车即可，最后会在.ssh目录下出现filename.pub、filename两个文件，第一个为公钥，需要放到远程中，第二个为私钥，用于通信时验证。 配置密钥到GitHub 为了使得本地的Git能够成功与GitHub中的远程仓库绑定，需要配置上一步生成的公钥。 进入到GitHub的setting中，选择SSH and GPG keys，点击New SSH key，将公钥中的内容复制并保存即可。需要注意的是，公钥可以使用记事本打开，保存时可能需要收取GitHub验证码。 除GitHub外的其他平台类似，当然我会选择在Pycharm中安装GitHub插件，然后通过登录账户实现本地与GitHub的通信，创建远程仓库并推送等操作都可以在GitHub插件的帮助下轻松完成，非常建议使用此种方式。 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:13 "},"BAT可执行文件.html":{"url":"BAT可执行文件.html","title":"BAT","keywords":"","body":"当有某项cmd指令需要被频繁操作时，每次打开cmd窗口后再输入指令运行非常麻烦 已开启mongo数据库服务为例，每次都要打开cmd窗口后运行 mongod --dbpath D:\\Euclid_Jie\\DBdata 所以将次命令作为一个可执行的bat文件，是非常有必要的，每次只要双击此bat就可以实现服务开启 下面解释bat生成流程 新建文本文件，更改文件类型为bat，将需要执行的命令直接写入文件即可，我会选择使用sublime_text进行更改文件类型和写入指令的操作，因为传统的记事本更改为bat后缀存在困难。 注意对bat文件命名为不要与本地命令相同，如果双击bat文件后，命令一直重复滚动，说明很可能遇到了此问题，需要对文件进行重命名，一般带几个中文，就不会有问题。 更进一步，将bat文件放在自己熟悉的地方，然后将其快捷方式放在桌面。这样既保证了不会误删文件，又可以对快捷方式的图标进行自定义。 图标ICO文件生成网站 图标下载网站集合，个人比较推荐的网站 构建bat的几种cmd命令 切换路径 E: # 先切换磁盘 cd E:\\Euclidbooktry # 再切换到路径 打开软件 切换到路径后执行exe，或者将exe加入系统路径 Typora.exe 打开文件 SUMMARY.md # 文件名+后缀 不关闭cmd窗口 pause # 回车后继续 cmd # 继续使用cmd 隐藏运行 @echo off if \"%1\"==\"h\" goto begin start mshta vbscript:createobject(\"wscript.shell\").run(\"\"\"%~nx0\"\" h\",0)(window.close)&&exit :begin ## 命令写在下面 SUMMARY.md 查看进程并结束进程 tasklist # 查看进程 taskkill /f /t /im Chrome.exe # 关闭浏览器 使用python执行程序文件 一般情况下直接 python demo.py 如果需要使用虚拟环境执行，需要先cd至虚拟环境目录（不能先激活再运行，会闪退） cd D:\\Program Files\\Anaconda3\\envs\\scrapy python D:\\Euclid_Jie\\proxy_pool\\proxyPool.py server Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:13 "},"stata相关操作.html":{"url":"stata相关操作.html","title":"stata","keywords":"","body":" 切换工作路径 cd C:\\Users\\欧玮杰\\Desktop\\商务统计上机作业 查看工作路径下所有文件 ls 导入数据，直接使用stata指定文件格式 use \"C:\\Users\\欧玮杰\\Desktop\\商务统计上机作业\\mus08psidextract.dta\" 输出为word asdoc reg Y Z 面板数据回归 设置观测个体和时序变量 xtset id t 混合回归 reg Y X 随机效应 xtreg Y X ,re r theta LM检验 xtreg Y X,re r theta estimates store RE xttest0 固定效应模型 xtreg lwage exp exp2 wks ed ,fe xtreg lwage exp exp2 wks ed ,fe r # 聚类稳健 带时间效应的固定效应模型 xtreg lwage exp exp2 wks ed i.t, fe r 豪斯曼检验 xtreg lwage exp exp2 wks ed,fe estimates store FE xtreg lwage exp exp2 wks ed re theta、estimates store RE hausman FE RE, constant sigmamore Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"装机.html":{"url":"装机.html","title":"装机","keywords":"","body":"2022年12月10日第一次装机（给大学朋友装的），一次性点亮，有点成就感，记录一下过程。以后万一自己装机可以用的到！ 主要硬件 CPU 主流为Intel和AMD两家，目前Intel已经更新到13代，AMD不知道情况，没用过，但是知道AMD功效小，而且可以超频（可玩性较大）。需要注意的是，Intel和AMD需要配不同的主板，而且不同的CPU有触点（Intel和AMD），针脚（Intel），洞（AMD），不同的CPU尺寸也不一样，所以买CPU和主板要对照着来。 主板 主板是所有硬件的载体，也就是个大的电路板，所有的硬件都要连在主板上。 内存 电脑的草稿纸，内存类型（DDR4、DDR5）频率等参数，需要对照主板和CPU，避免出现不匹配的情况（性能跑不满、或性能瓶颈）。最好是两条内存，组成双通道，效率会比较高。 硬盘 硬盘就是放软件和文件的地方。类型为PIC4.0、PCI3.0，一般来说越贵越好，文件读取速度会快很多。可以买一个SSD（速度快）+机械盘（装文件，慢一点）。 散热 CPU散热一般就是直接连接CPU上，然后扣一个风扇上。更高级的散热还有水冷，以及机箱上可以装一些风扇，形成风道。 显卡 对于台式机来说，显卡还是很有必要的，也是两个厂家。一个是英伟达、一个是AMD。没有特别高的要求的话，一张随便的卡就成，如果不装显卡的话，需要CPU自己带集成显卡。 电源 电源应该是最重要的了，只有这个才能让这个电脑跑起来。走线会很复杂。具体就是，主板供电（很大一排）+CPU供电（8PIN）+显卡（8PIN+）供电，然后风扇的电（4PIN）连接到主板上（电到主板上，然后主板风扇）。最后的就是把机箱上开机键那些连接到主板上（右下角），分别有开机（2针）、重启（2针）、USB接口（8缺1,USB2.0和USB3.0不一样），声音输出输入（各1针）。 大概就是这些了！点亮就查个系统盘安装就成！ Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"文献相关.html":{"url":"文献相关.html","title":"文献相关","keywords":"","body":"在此记录一些文献，著作相关内容 论文文献 知乎上有个文章介绍了很多文献来源，如果能科学上网那还是首推谷歌学术 通过DOI号下载 整合地址 SICHUB Library Genesis+ 著作 主要放一些老师的网页课件、专著 李东风老师 金融时间序列分析讲义 R语言教程 统计计算 统计学专著 The Elements of Statistical Learning，对应中文讲解](https://esl.hohoweiya.xyz/03-Linear-Methods-for-Regression/3.2-Linear-Regression-Models-and-Least-Squares/index.html)) 数据科学 Python Data Science Handbook (jakevdp.github.io) Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "},"本文排版.html":{"url":"本文排版.html","title":"本文排版","keywords":"","body":"GitBook网页端托管，存在一定的问题，并不能显示本地Typora的MarkDown完整内容，故此记录注意事项，期望找到一种本地和网页端一致的书写方式。 本文使用方案为：Typora + GitHub仓库托管 + GitBook网页端 插入图片缩放50%为合适比例，网页端较为舒适，同时通过html语言设置居中 文章开头不能为一级标题，GitBook网页端会默认将章节名渲染为一级标题并置于开头 数学符号排版需要注意不能使用单美元内联，无法如本地渲染一致$\\lambda$，需要使用双美元内联$$\\lambda$$ 一些希腊数学符号一定写成Latex格式，不要直接复制而来，会导致网页端渲染崩溃 Copyright © Euclid-Jie 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-27 13:43:14 "}}